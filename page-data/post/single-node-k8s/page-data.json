{"componentChunkName":"component---src-template-blog-tsx","path":"/post/single-node-k8s","result":{"data":{"mdx":{"frontmatter":{"title":"Single Node K8s in China","author":"onichandame","date":"2020-04-07T00:00:00.000Z"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Single Node K8s in China\",\n  \"author\": \"onichandame\",\n  \"date\": \"2020-04-07T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#scenario\"\n  }), \"Scenario\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#materials\"\n  }), \"Materials\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#procedures\"\n  }), \"Procedures\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#install-os\"\n  }), \"Install OS\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#configure-firewall\"\n  }), \"Configure Firewall\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#setup-bridge\"\n  }), \"Setup Bridge\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#setup-container-runtime\"\n  }), \"Setup Container Runtime\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#install-kubectl-kubelet-and-kubeadm\"\n  }), \"Install kubectl, kubelet and kubeadm\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#boot\"\n  }), \"Boot\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#setup-kubectl\"\n  }), \"Setup kubectl\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#install-network-plugin\"\n  }), \"Install Network Plugin\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#turn-off-master-protection\"\n  }), \"Turn off Master Protection\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#install-load-balancer\"\n  }), \"Install Load Balancer\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#install-ingress-controller\"\n  }), \"Install Ingress Controller\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#%E7%BB%93%E8%AF%AD\"\n  }), \"\\u7ED3\\u8BED\"))), mdx(\"h1\", {\n    \"id\": \"scenario\"\n  }, \"Scenario\"), mdx(\"p\", null, \"My new project needs to run on a remote physical machine. The project itself is coposed of many microservices. Therefore the best way to deploy is container orchestration. But the constraints of k8s plus physical machine plush China introduces many complexities to the setup.\"), mdx(\"h1\", {\n    \"id\": \"materials\"\n  }, \"Materials\"), mdx(\"p\", null, \"The materials in hand are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"one physical server\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"CPU\\uFF1AE3-1220v6\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"RAM\\uFF1A32GB\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"HDD\\uFF1A4TB\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A series of vacant IP address in LAN\")), mdx(\"h1\", {\n    \"id\": \"procedures\"\n  }, \"Procedures\"), mdx(\"h2\", {\n    \"id\": \"install-os\"\n  }, \"Install OS\"), mdx(\"p\", null, \"I choose the latest CentOS 7 as CentOS 8 still lacks the official support to docker. If choose not to use docker or containerd, CentOS 8 is fine. Other distros are not recommended here as I haven't tried them.\"), mdx(\"h2\", {\n    \"id\": \"configure-firewall\"\n  }, \"Configure Firewall\"), mdx(\"p\", null, \"According to the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/\"\n  }), \"official docs\"), \", the master and the worker require 7 ports and 1 series of ports open. According to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network\"\n  }), \"the docs\"), \", 2 more ports need to be open in order to use flannel. And according to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.nginx.com/nginx-ingress-controller/installation/installation-with-manifests/\"\n  }), \"the docs\"), \", port 80 and 443 need to be opened.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"firewall-cmd --zone=public --permanent --add-port=443/tcp\\nfirewall-cmd --zone=public --permanent --add-port=80/tcp\\nfirewall-cmd --zone=public --permanent --add-port=6443/tcp\\nfirewall-cmd --zone=public --permanent --add-port=2379-2380/tcp\\nfirewall-cmd --zone=public --permanent --add-port=10250-10252/tcp\\nfirewall-cmd --zone=public --permanent --add-port=8285/tcp\\nfirewall-cmd --zone=public --permanent --add-port=8472/tcp\\nfirewall-cmd --reload\\n\")), mdx(\"h2\", {\n    \"id\": \"setup-bridge\"\n  }, \"Setup Bridge\"), mdx(\"p\", null, \"According to the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/\"\n  }), \"official docs\"), \", the network bridge needs to be setup.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"cat <<EOF > /etc/sysctl.d/k8s.conf\\nnet.bridge.bridge-nf-call-ip6tables = 1\\nnet.bridge.bridge-nf-call-iptables = 1\\nEOF\\nsysctl --system\\n\")), mdx(\"p\", null, \"Note: Check the output of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"lsmod | grep br_netfilter\"), \"is not empty before running the above commands. If empty, it is requried to run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"modprobe br_netfilter\"), \" and check again.\"), mdx(\"h2\", {\n    \"id\": \"setup-container-runtime\"\n  }, \"Setup Container Runtime\"), mdx(\"p\", null, \"I choose to use docker. The detailed steps are described \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://kubernetes.io/docs/setup/production-environment/container-runtimes/#docker\"\n  }), \"here\"), \". But I did it according to the CentOS's official recommendation. If you choose containerd or cri-o, please refer to the official guides.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"yum install epel-release -y\\nyum install docker-ce -y\\n\")), mdx(\"h2\", {\n    \"id\": \"install-kubectl-kubelet-and-kubeadm\"\n  }, \"Install kubectl, kubelet and kubeadm\"), mdx(\"p\", null, \"Next step is to install the deployment tools.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"cat <<EOF > /etc/yum.repos.d/kubernetes.repo\\n[kubernetes]\\nname=Kubernetes\\nbaseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-$basearch\\nenabled=1\\ngpgcheck=1\\nrepo_gpgcheck=1\\ngpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg\\nexclude=kubelet kubeadm kubectl\\nEOF\\n\\n# Set SELinux in permissive mode (effectively disabling it)\\nsetenforce 0\\nsed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config\\n\\nyum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes\\n\\nsystemctl enable --now kubelet\\n\")), mdx(\"p\", null, \"Now that kubelet is ready to use. The next step is to bootstrap the cluster.\"), mdx(\"h2\", {\n    \"id\": \"boot\"\n  }, \"Boot\"), mdx(\"p\", null, \"Having done all the steps above, it is time to boot the cluster.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"kubeadm init --pod-network-cidr=10.244.0.0/16 --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers\\n\")), mdx(\"p\", null, \"As I choose to use flannel, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--pod-network-cidr=10.244.0.0/16\"), \" is required. As I am deploying in China, a mirror is required \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--image-repository registry.cn-hangzhou.aliyuncs.com/google_containers\"), \".\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kubeadm join <control-plane-host>:<control-plane-port> --token <token> --discovery-token-ca-cert-hash sha256:<hash>\"), \" part from the output needs to be recorded in case new nodes will be added in the future.\"), mdx(\"h2\", {\n    \"id\": \"setup-kubectl\"\n  }, \"Setup kubectl\"), mdx(\"p\", null, \"\\u5982\\u679C\\u5F53\\u524D\\u7528\\u6237\\u975E root\\uFF0C\\u9700\\u8981\\u914D\\u7F6E kubectl \\u4EE5\\u8FDE\\u63A5\\u96C6\\u7FA4\\u3002\\nIf the current user is not root, kubectl needs to be configured in order to connect to the cluster.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"mkdir -p $HOME/.kube\\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\\n\")), mdx(\"p\", null, \"If the current user is root, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"export KUBECONFIG=/etc/kubernetes/admin.conf\"), \" is requried to setup kubectl.\"), mdx(\"h2\", {\n    \"id\": \"install-network-plugin\"\n  }, \"Install Network Plugin\"), mdx(\"p\", null, \"As k8s is designed for cluster, pods from different hosts require a network plugin to communicate through LAN. According to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network\"\n  }), \"the official docs\"), \", I choose flannel. I have seen a report that other plugins fail as DNS where flannel is stil functional. The source of the report is lost in my memory though.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/2140ac876ef134e0ed5af15c65e414cf26827915/Documentation/kube-flannel.yml\\n\")), mdx(\"h2\", {\n    \"id\": \"turn-off-master-protection\"\n  }, \"Turn off Master Protection\"), mdx(\"p\", null, \"k8s by default does not allow master to run non-system pods. But I need to run workloads on master so this protection needs to be turned off.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"kubectl taint nodes --all node-role.kubernetes.io/master-\\n\")), mdx(\"h2\", {\n    \"id\": \"install-load-balancer\"\n  }, \"Install Load Balancer\"), mdx(\"p\", null, \"On the cloud like AWS or GKE, service can retrieve a public IP easily using LoadBalancer. But this function depends on the cloud provider's load balancer. Now it is requried to install a load balancer. I choose MetalLB. \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://metallb.universe.tf/installation/\"\n  }), \"Here\"), \" is the official docs.\"), mdx(\"p\", null, \"Firstly edit the kube-proxy configuration:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"kubectl edit configmap -n kube-system kube-proxy\\n\")), mdx(\"p\", null, \"Add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"strictARP: true\"), \" under \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ipvs\"), \".\"), mdx(\"p\", null, \"I haven't learned the fundamental reasons behind this, but I guess that it has something to do with the arp mechanism.\"), mdx(\"p\", null, \"Now it is ready to deploy MetalLB service:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"kubectl apply -f https://raw.githubusercontent.com/google/metallb/v0.9.3/manifests/namespace.yaml\\nkubectl apply -f https://raw.githubusercontent.com/google/metallb/v0.9.3/manifests/metallb.yaml\\nkubectl create secret generic -n metallb-system memberlist --from-literal=secretkey=\\\"$(openssl rand -base64 128)\\\"\\n\")), mdx(\"p\", null, \"Now that you can check if MetalLB related containers are online using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kubectl get pods --all-namespaces\"), \".\"), mdx(\"p\", null, \"The next step is to configure MetalLB. In a nutshell MetalLB needs to know what IP addresses can be distributed to the services.\"), mdx(\"p\", null, \"Open a new yaml file and add the content:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-yaml\"\n  }), \"apiVersion: v1\\nkind: ConfigMap\\nmetadata:\\n  namespace: metallb-system\\n  name: config\\ndata:\\n  config: |\\n    address-pools:\\n    - name: default\\n      protocol: layer2\\n      addresses:\\n      - 192.168.1.240-192.168.1.250\\n\")), mdx(\"p\", null, \"The addresses value specifies the available IP addresses. All other configurations can be left unchanged.\"), mdx(\"p\", null, \"MetalLB can now be deployed by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kubectl apply -f <config file>\"), \".\"), mdx(\"p\", null, \"The cluster can now deploy service of the type LoadBalancer.\"), mdx(\"h2\", {\n    \"id\": \"install-ingress-controller\"\n  }, \"Install Ingress Controller\"), mdx(\"p\", null, \"LoadBalancer is the most common service type, but a bunch of IP is not easy to manage. Since k8s 1.1 there is a new resource type of Ingress. It functions like Apache or Nginx to provide a more convenient control over the incoming traffic.\"), mdx(\"p\", null, \"One of Ingress's functions is the route according to the domain. For instance there are 2 domains now, aaa.com and bbb.com each served by server A and server B. After domain resolution both are pointing to the same IP, the IP of the node where the Ingress controller is run. When a viewer visits aaa.com, Ingress routes the traffic to server A. The same logic applies to the server B.\"), mdx(\"p\", null, \"To be able to use Ingress, an Ingress Controller needs to be installed.\"), mdx(\"p\", null, \"I choose Nginx-Ingress. The first step is to clone the configuration files.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"git clone https://github.com/nginxinc/kubernetes-ingress/ --single-branch --branch v1.6.3\\n\")), mdx(\"p\", null, \"Now cd into the sub directory deployments and run the following commands in order.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"kubectl apply -f common/ns-and-sa.yaml\\nkubectl apply -f rbac/rbac.yaml\\nkubectl apply -f common/default-server-secret.yaml\\nkubectl apply -f common/nginx-config.yaml\\nkubectl apply -f common/custom-resource-definitions.yaml\\nkubectl apply -f daemon-set/nginx-ingress.yaml\\n\")), mdx(\"p\", null, \"Now check if nginx-ingress is online using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$ kubectl get pods --namespace=nginx-ingress\"), \".\"), mdx(\"h1\", {\n    \"id\": \"conclusion\"\n  }, \"Conclusion\"), mdx(\"p\", null, \"Now if everything went fine, a single-node k8s cluster is ready to use. All features of k8s 1.18 are supported.\"));\n}\n;\nMDXContent.isMDXComponent = true;","headings":[{"value":"Scenario","depth":1},{"value":"Materials","depth":1},{"value":"Procedures","depth":1},{"value":"Install OS","depth":2},{"value":"Configure Firewall","depth":2},{"value":"Setup Bridge","depth":2},{"value":"Setup Container Runtime","depth":2},{"value":"Install kubectl, kubelet and kubeadm","depth":2},{"value":"Boot","depth":2},{"value":"Setup kubectl","depth":2},{"value":"Install Network Plugin","depth":2},{"value":"Turn off Master Protection","depth":2},{"value":"Install Load Balancer","depth":2},{"value":"Install Ingress Controller","depth":2},{"value":"Conclusion","depth":1}]}},"pageContext":{"locale":"en","type":"post","title":"Single Node K8s in China","date":"2020-04-07T00:00:00.000Z","author":"onichandame"}}}