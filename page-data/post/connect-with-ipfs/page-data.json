{"componentChunkName":"component---src-template-blog-tsx","path":"/post/connect-with-ipfs","result":{"data":{"mdx":{"frontmatter":{"title":"Connect with IPFS","author":"onichandame","date":"2020-10-19T00:00:00.000Z"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Connect with IPFS\",\n  \"author\": \"onichandame\",\n  \"date\": \"2020-10-19T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#windows-setup\"\n  }), \"Windows Setup\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#wsl-2\"\n  }), \"WSL 2\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#restart-on-reboot\"\n  }), \"Restart on Reboot\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#connection-setup\"\n  }), \"Connection Setup\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#ssh-across-nat\"\n  }), \"SSH Across NAT\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#server-setup\"\n  }), \"Server Setup\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#client-setup\"\n  }), \"Client Setup\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#proxy\"\n  }), \"Proxy\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#server\"\n  }), \"Server\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#client\"\n  }), \"Client\"))))), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://ipfs.io/\"\n  }), \"IPFS\"), \" is designed to lay the foundation of the next-generation web, in hope of replacing the old HTTP-based web. It's potential is more than it's design though.\"), mdx(\"p\", null, \"Built on top of the p2p network connected by \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/libp2p/specs\"\n  }), \"libp2p\"), \", on which IPFS is based, many fancy applications becomes possible.\"), mdx(\"p\", null, \"The comman setup for all nodes are below:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"ipfs config --json Experimental.Libp2pStreamMounting true\\nipfs config --json Swarm.EnableAutoRelay 'true'\\n\")), mdx(\"p\", null, \"The first command allows to open long-running connections between nodes. The second command enables the automatic detection and usage of relay servers.\"), mdx(\"h1\", null, \"Windows Setup\"), mdx(\"p\", null, \"Before diving into the applications, some precautions are required when a node resides on a Windows machine.\"), mdx(\"h2\", null, \"WSL 2\"), mdx(\"p\", null, \"The latest version of WSL 2 is a blazing fast Linux environment on Windows machines. It is recommended to run applications in WSL 2 if possible. Hence I run a go-ipfs instance in WSL 2 and use it as a server for many cases.\"), mdx(\"h2\", null, \"Restart on Reboot\"), mdx(\"p\", null, \"A common requirement for a server is to restart the services on system reboot. This can be achieved using Windows Task Scheduler.\"), mdx(\"p\", null, \"The following services should be restarted on reboot:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"the IPFS node: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ipfs daemon\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"the sshd instance: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"/usr/sbin/sshd\"), \" (if used as an SSH server)\")), mdx(\"p\", null, \"The port forward services described below may also be managed by Task Scheduler.\"), mdx(\"h1\", null, \"Connection Setup\"), mdx(\"p\", null, \"Most of the existing applications are based on address-based routing. But IPFS is mostly used for content-based routing. This difference makes many trivial applications troublesome.\"), mdx(\"p\", null, \"To connect 2 IPFS nodes, one needs to initiate the connection from one node(client) to another(server).\"), mdx(\"p\", null, \"The command to connect 2 nodes is:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"ipfs ping <Server ID>\\nipfs swarm connect /p2p/<Server ID>\\n\")), mdx(\"p\", null, \"In the cases when the direct connection is not successful, one simply needs to ping the server.\"), mdx(\"h1\", null, \"SSH Across NAT\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Ssh_(Secure_Shell)\"\n  }), \"SSH\"), \" is a remote login tool based on a TCP connection. IPFS has \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ipfs/go-ipfs/blob/master/docs/experimental-features.md#ipfs-p2p\"\n  }), \"an experimental feature\"), \" that is able to set up a TCP connection between two nodes regardless of the traditional network topology. That being said, it can connect machines behind impenetrable NAT.\"), mdx(\"h2\", null, \"Server Setup\"), mdx(\"p\", null, \"The server needs to listen on connections and forward the stream to the sshd instance.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"ipfs p2p listen /x/ssh /ip4/127.0.0.1/tcp/22\\n\")), mdx(\"h2\", null, \"Client Setup\"), mdx(\"p\", null, \"On the client side things are similar. I have made \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://hub.docker.com/layers/onichandame/ipfs/ssh/images/sha256-7bbfb56ab201408539b6735409f5a6d737609bc06f8461a2d568cb3495203ce9?context=explore\"\n  }), \"a docker image\"), \" for the client setup. The Dockerfile can be found \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/onichandame/docker-ipfs/blob/ssh/Dockerfile\"\n  }), \"here\"), \". This image can also be used as the server. The only manual step required is to run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/usr/sbin/sshd\"), \".\"), mdx(\"h1\", null, \"Proxy\"), mdx(\"p\", null, \"A common scenario is to run a web service on a server and access the server from a client. The protocol is usually based on TCP. To proxy TCP connections, the following setup is required.\"), mdx(\"h2\", null, \"Server\"), mdx(\"p\", null, \"The server needs to listen on a port.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"ipfs p2p listen /x/kickass/1.0 /ip4/127.0.0.1/tcp/<Server port>\\n\")), mdx(\"h2\", null, \"Client\"), mdx(\"p\", null, \"The client needs to proxy the port exposed by the server to a local port.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"ipfs p2p forward /x/kickass/1.0 /ip4/0.0.0.0/tcp/<Local port> /p2p/<Server port>\\n\")), mdx(\"p\", null, \"Now the web service on the server can be accessed from the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Local port\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","headings":[{"value":"Windows Setup","depth":1},{"value":"WSL 2","depth":2},{"value":"Restart on Reboot","depth":2},{"value":"Connection Setup","depth":1},{"value":"SSH Across NAT","depth":1},{"value":"Server Setup","depth":2},{"value":"Client Setup","depth":2},{"value":"Proxy","depth":1},{"value":"Server","depth":2},{"value":"Client","depth":2}]}},"pageContext":{"locale":"en","type":"post","title":"Connect with IPFS","date":"2020-10-19T00:00:00.000Z","author":"onichandame"}},"staticQueryHashes":["440568431","840944156","899237799","899237799"]}