{"componentChunkName":"component---src-template-blog-tsx","path":"/post/use-jest-for-unit-test","result":{"data":{"mdx":{"frontmatter":{"title":"Use Jest for Unit Test","author":"onichandame","date":"2020-06-09T00:00:00.000Z"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Use Jest for Unit Test\",\n  \"author\": \"onichandame\",\n  \"date\": \"2020-06-09T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"#asynchronous-code\"\n  }), \"Asynchronous Code\"))), mdx(\"p\", null, \"Unit test is a must for autiomated CI/CD workflow. Here I record some challenges solved with Jest.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-typescript\"\n  }), \"describe(\\\"module 1\\\", () => {\\n  test(\\\"dances\\\", () => expect(module1.dance()).toBeTruthy())\\n})\\n\")), mdx(\"h1\", {\n    \"id\": \"asynchronous-code\"\n  }, \"Asynchronous Code\"), mdx(\"p\", null, \"Jest runs tests in parallel so each test must have a clear termination point. If everything is synchronous, simply return an expect function will tell Jest where to stop.\"), mdx(\"p\", null, \"The problem becomes apparent if the test callback is asynchronous.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-typescript\"\n  }), \"describe(\\\"module 1\\\", () => {\\n  test(\\\"dances\\\", async () => expect(module1.dance()).toBeTruthy())\\n})\\n\")), mdx(\"p\", null, \"The above code still functions well if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"module1.dance()\"), \" is synchronous. What happens if the resolved value needs to be tested?\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-typescript\"\n  }), \"describe(\\\"module 1\\\", () => {\\n  test(\\\"dances\\\", async () => expect(await module1.dance()).toBeTruthy())\\n})\\n\")), mdx(\"p\", null, \"The above is a simple solution to the simple question. What if the question becomes more complicated?\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-typescript\"\n  }), \"describe(\\\"module 1\\\", done => {\\n  test(\\\"dances\\\", async () => {\\n    expect.assertions(1)\\n    const dance = await module1.dance()\\n    dance.on(\\\"spin\\\", speed => {\\n      expect(speed).toBeGreaterThan(5)\\n      done()\\n    })\\n  })\\n})\\n\")), mdx(\"p\", null, \"The above code is an example where the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"done\"), \" function is useful. The test is considered finished when the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"done\"), \" function is called inside the test. Another use case of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"done\"), \" is the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"beforeAll\"), \" hook.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-typescript\"\n  }), \"beforeAll(async done => {\\n  await dep1\\n  await dep2\\n  done()\\n})\\n\")), mdx(\"p\", null, \"Without the use of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"done\"), \", Jest will run the callback synchronously so the tests will start before \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dep1\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dep2\"), \" are resolved.\"));\n}\n;\nMDXContent.isMDXComponent = true;","headings":[{"value":"Asynchronous Code","depth":1}]}},"pageContext":{"locale":"en","type":"post","title":"Use Jest for Unit Test","date":"2020-06-09T00:00:00.000Z","author":"onichandame"}}}